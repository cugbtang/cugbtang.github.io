<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>✌yesplease's blog</title><link>http://cugbtang.github.io/</link><description>Recent content on ✌yesplease's blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 01 Mar 2018 16:01:23 +0800</lastBuildDate><atom:link href="http://cugbtang.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>About</title><link>http://cugbtang.github.io/about/</link><pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate><guid>http://cugbtang.github.io/about/</guid><description>&lt;p>Hugo is a static site engine written in Go.&lt;/p>
&lt;p>It makes use of a variety of open source projects including:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/spf13/cobra">Cobra&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/spf13/viper">Viper&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/spf13/jWalterWeatherman">J Walter Weatherman&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/spf13/cast">Cast&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Learn more and contribute on &lt;a href="https://github.com/gohugoio">GitHub&lt;/a>.&lt;/p></description></item><item><title>Container, how to play?</title><link>http://cugbtang.github.io/post/series-container-1/</link><pubDate>Thu, 01 Mar 2018 16:01:23 +0800</pubDate><guid>http://cugbtang.github.io/post/series-container-1/</guid><description>&lt;p>container technology become a necessary for developer during operating the linux system.&lt;/p>
&lt;h2 id="1namespace">1、namespace&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>定义&lt;/p>
&lt;p>namespace是 Linux 内核的一项功能，该功能对内核资源进行分区，以使一组进程看到一组资源，而另一组进程看到另一组资源。namespace 的工作方式通过为一组资源和进程设置相同的 namespace 而起作用，但是这些 namespace 引用了不同的资源。资源可能存在于多个 namespace 中。这些资源可以是进程ID、主机名、用户ID、文件名、与网络访问相关的名称和进程间通信。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>特征&lt;/p>
&lt;p>可以实现在同一主机系统中对进程ID、主机名、用户名ID、文件名、网络和进程间通信等资源的隔离。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>类型&lt;/p>
&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">namespace&lt;/th>
&lt;th style="text-align:center">summary&lt;/th>
&lt;th style="text-align:center">kernel&lt;/th>
&lt;th>describe&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">Mount(mnt)&lt;/td>
&lt;td style="text-align:center">隔离挂载点&lt;/td>
&lt;td style="text-align:center">2.4.19&lt;/td>
&lt;td>隔离不同的进程或进程组看到的挂载点，实现容器内只能看到自己的挂在信息，在容器内的挂载操作不会影响主机的挂载目录&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Process ID(pid)&lt;/td>
&lt;td style="text-align:center">隔离进程 ID&lt;/td>
&lt;td style="text-align:center">2.6.24&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Network(net)&lt;/td>
&lt;td style="text-align:center">隔离网络设备，端口号等&lt;/td>
&lt;td style="text-align:center">2.6.29&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Interprocess Communication(ipc)&lt;/td>
&lt;td style="text-align:center">隔离 System VIPC 和 POSIX message queues&lt;/td>
&lt;td style="text-align:center">2.6.19&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">UTS Namespace(uts)&lt;/td>
&lt;td style="text-align:center">隔离主机名和域名&lt;/td>
&lt;td style="text-align:center">2.6.19&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">User Namespace(user)&lt;/td>
&lt;td style="text-align:center">隔离用户和用户组&lt;/td>
&lt;td style="text-align:center">3.8&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Control group(cgroup) Namespce&lt;/td>
&lt;td style="text-align:center">隔离 Cgroups 根目录&lt;/td>
&lt;td style="text-align:center">4.6&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Time Namespace&lt;/td>
&lt;td style="text-align:center">隔离系统时间&lt;/td>
&lt;td style="text-align:center">5.6&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="mount-namespace">Mount Namespace&lt;/h3>
&lt;p>使用 unshare 命令可以新建 Mount Namespace，并且在新建的 Mount Namespace 内 mount 是和外部完全隔离的。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>创建一个bash 进程并且新建一个 Mount Namespace&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>vagrant@localhost ~&lt;span class="o">]&lt;/span>$ sudo unshare --mount --fork /bin/bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@localhost vagrant&lt;span class="o">]&lt;/span>&lt;span class="c1">#&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>验证在独立的 namespce 内挂载文件，不影响别的&lt;/p>
&lt;p>在 /tmp 目录下创建一个目录&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@localhost vagrant&lt;span class="o">]&lt;/span>&lt;span class="c1"># mkdir /tmp/tmpfs&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用 mount 命令挂载一个 tmpfs 类型的目录&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@localhost vagrant&lt;span class="o">]&lt;/span>&lt;span class="c1"># mount -t tmpfs -o size=20m tmpfs /tmp/tmpfs&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用 df 命令查看已经挂载的目录信息&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@localhost vagrant&lt;span class="o">]&lt;/span>&lt;span class="c1"># df -h&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Filesystem Size Used Avail Use% Mounted on
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/dev/sda1 40G 3.8G 37G 10% /
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">devtmpfs 457M &lt;span class="m">0&lt;/span> 457M 0% /dev
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tmpfs 464M &lt;span class="m">0&lt;/span> 464M 0% /dev/shm
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tmpfs 464M &lt;span class="m">0&lt;/span> 464M 0% /sys/fs/cgroup
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tmpfs 464M 13M 451M 3% /run
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tmpfs 93M &lt;span class="m">0&lt;/span> 93M 0% /run/user/1000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">//172.29.0.1/vgt-2469b42ebff188de622646551002b263-6ad5fdbcbf2eaa93bd62f92333a2e6e5 466G 171G 295G 37% /vagrant
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tmpfs 20M &lt;span class="m">0&lt;/span> 20M 0% /tmp/tmpfs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>新打开一个命令窗口，执行 df 命令查看主机的挂载信息&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>vagrant@localhost ~&lt;span class="o">]&lt;/span>$ df -h
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Filesystem Size Used Avail Use% Mounted on
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">devtmpfs 457M &lt;span class="m">0&lt;/span> 457M 0% /dev
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tmpfs 464M &lt;span class="m">0&lt;/span> 464M 0% /dev/shm
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tmpfs 464M 13M 451M 3% /run
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tmpfs 464M &lt;span class="m">0&lt;/span> 464M 0% /sys/fs/cgroup
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/dev/sda1 40G 3.8G 37G 10% /
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">//172.29.0.1/vgt-2469b42ebff188de622646551002b263-6ad5fdbcbf2eaa93bd62f92333a2e6e5 466G 171G 295G 37% /vagrant
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tmpfs 93M &lt;span class="m">0&lt;/span> 93M 0% /run/user/1000
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>基本验证完毕。接着我们查看新的mount namespace 信息&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@localhost vagrant&lt;span class="o">]&lt;/span>&lt;span class="c1"># ls -l /proc/self/ns/&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">total &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">lrwxrwxrwx. &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 09:56 ipc -&amp;gt; ipc:&lt;span class="o">[&lt;/span>4026531839&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">lrwxrwxrwx. &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 09:56 mnt -&amp;gt; mnt:&lt;span class="o">[&lt;/span>4026532117&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">lrwxrwxrwx. &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 09:56 net -&amp;gt; net:&lt;span class="o">[&lt;/span>4026531956&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">lrwxrwxrwx. &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 09:56 pid -&amp;gt; pid:&lt;span class="o">[&lt;/span>4026531836&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">lrwxrwxrwx. &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 09:56 user -&amp;gt; user:&lt;span class="o">[&lt;/span>4026531837&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">lrwxrwxrwx. &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 09:56 uts -&amp;gt; uts:&lt;span class="o">[&lt;/span>4026531838&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>新打开一个命令窗口，使用相同的命令查看主机上的 namespace 信息&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>vagrant@localhost ~&lt;span class="o">]&lt;/span>$ ls -l /proc/self/ns/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">total &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">lrwxrwxrwx. &lt;span class="m">1&lt;/span> vagrant vagrant &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 09:57 ipc -&amp;gt; ipc:&lt;span class="o">[&lt;/span>4026531839&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">lrwxrwxrwx. &lt;span class="m">1&lt;/span> vagrant vagrant &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 09:57 mnt -&amp;gt; mnt:&lt;span class="o">[&lt;/span>4026531840&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">lrwxrwxrwx. &lt;span class="m">1&lt;/span> vagrant vagrant &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 09:57 net -&amp;gt; net:&lt;span class="o">[&lt;/span>4026531956&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">lrwxrwxrwx. &lt;span class="m">1&lt;/span> vagrant vagrant &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 09:57 pid -&amp;gt; pid:&lt;span class="o">[&lt;/span>4026531836&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">lrwxrwxrwx. &lt;span class="m">1&lt;/span> vagrant vagrant &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 09:57 user -&amp;gt; user:&lt;span class="o">[&lt;/span>4026531837&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">lrwxrwxrwx. &lt;span class="m">1&lt;/span> vagrant vagrant &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 09:57 uts -&amp;gt; uts:&lt;span class="o">[&lt;/span>4026531838&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="pid-namespace">PID Namespace&lt;/h3>
&lt;blockquote>
&lt;p>用来隔离进程，在不同的namespace内可以拥有相同的进程号&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>创建一个 bash 进程，并且新建一个 PID Namespace&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>vagrant@localhost ~&lt;span class="o">]&lt;/span>$ sudo unshare --pid --fork --mount-proc /bin/bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@localhost vagrant&lt;span class="o">]&lt;/span>&lt;span class="c1">#&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>在当前的命令行窗口使用 ps aux 命令查看进程信息&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@localhost vagrant&lt;span class="o">]&lt;/span>&lt;span class="c1"># ps aux&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">root &lt;span class="m">1&lt;/span> 0.0 0.2 &lt;span class="m">15792&lt;/span> &lt;span class="m">2616&lt;/span> pts/3 S 13:59 0:00 /bin/bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">root &lt;span class="m">16&lt;/span> 0.0 0.1 &lt;span class="m">55192&lt;/span> &lt;span class="m">1844&lt;/span> pts/3 R+ 14:02 0:00 ps aux
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="uts-namespace">UTS Namespace&lt;/h3>
&lt;blockquote>
&lt;p>它允许每个UTS Namespace 拥有一个独立的主机名&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>使用 unshare 命令创建一个 UTS Namespace&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>vagrant@localhost ~&lt;span class="o">]&lt;/span>$ sudo unshare --uts --fork /bin/bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@localhost vagrant&lt;span class="o">]&lt;/span>&lt;span class="c1">#&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用 hostname 命令设置主机&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@localhost vagrant&lt;span class="o">]&lt;/span>&lt;span class="c1"># hostname -b docker&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@localhost vagrant&lt;span class="o">]&lt;/span>&lt;span class="c1"># hostname&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>新打开一个命令行窗口，使用相同的命令查看主机的hostname&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@localhost vagrant&lt;span class="o">]&lt;/span>&lt;span class="c1"># localhost&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="ipc-namespace">IPC Namespace&lt;/h3>
&lt;blockquote>
&lt;p>主要用来隔离进程间通信的。PID Namespace 和 IPC Namespace一起使用可以实现同一 IPC Namespace 内的进程彼此可以通信，不同 IPC Namespace 的进程却不能通信。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>使用 unshare 命令创建一个 IPC Namespace&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>vagrant@docker ~&lt;span class="o">]&lt;/span>$ sudo unshare --ipc --fork /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>另起一个窗口，查看系统的通信进程&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>vagrant@docker ~&lt;span class="o">]&lt;/span>$ ipcs -q
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">------ Message Queues --------
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">key msqid owner perms used-bytes messages
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>在新的ipc namespace下新建一个进程通信队列&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@docker vagrant&lt;span class="o">]&lt;/span>&lt;span class="c1"># ipcmk -Q&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Message queue id: &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>查看当前ipc namespace 下的系统通信队列列表&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@docker vagrant&lt;span class="o">]&lt;/span>&lt;span class="c1"># ipcs -q&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">------ Message Queues --------
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">key msqid owner perms used-bytes messages
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0x2ae315e9 &lt;span class="m">0&lt;/span> root &lt;span class="m">644&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>再次查看主机的系统通信队列&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>vagrant@docker ~&lt;span class="o">]&lt;/span>$ ipcs -q
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">------ Message Queues --------
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">key msqid owner perms used-bytes messages
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="user-namespace">User Namespace&lt;/h3>
&lt;blockquote>
&lt;p>主要用来隔离用户和用户组。可以实现进程在容器内拥有 root 权限， 而在主机上却只是普通用户。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>以普通用户的身份创建一个 User Namespace&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>vagrant@docker ~&lt;span class="o">]&lt;/span>$ unshare --user --fork /bin/bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">unshare: unshare failed: Invalid argument
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看内核版本&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>vagrant@docker ~&lt;span class="o">]&lt;/span>$ uname -a
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Linux docker 3.10.0-1127.el7.x86_64 &lt;span class="c1">#1 SMP Tue Mar 31 23:36:51 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查阅资料&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># max_user_namespaces文件记录了允许创建的user namespace数量，我的CentOS 7.5默认是0，修改之&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">echo&lt;/span> &lt;span class="m">2147483647&lt;/span> &amp;gt; /proc/sys/user/max_user_namespaces
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 再次运行&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>vagrant@docker ~&lt;span class="o">]&lt;/span>$ unshare --user -r /bin/bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@docker ~&lt;span class="o">]&lt;/span>&lt;span class="c1">#&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>执行 id 命令查看当前的用户信息&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@docker ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># id&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">uid&lt;/span>&lt;span class="o">=&lt;/span>0&lt;span class="o">(&lt;/span>root&lt;span class="o">)&lt;/span> &lt;span class="nv">gid&lt;/span>&lt;span class="o">=&lt;/span>0&lt;span class="o">(&lt;/span>root&lt;span class="o">)&lt;/span> &lt;span class="nv">groups&lt;/span>&lt;span class="o">=&lt;/span>0&lt;span class="o">(&lt;/span>root&lt;span class="o">)&lt;/span>,65534&lt;span class="o">(&lt;/span>nfsnobody&lt;span class="o">)&lt;/span> &lt;span class="nv">context&lt;/span>&lt;span class="o">=&lt;/span>unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>在当前窗口执行 reboot 命令&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@docker ~&lt;span class="o">]&lt;/span>&lt;span class="c1"># reboot&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Failed to open /dev/initctl: Permission denied
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Failed to talk to init daemon.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="net-namespace">Net Namespace&lt;/h3>
&lt;blockquote>
&lt;p>用来隔离网络设备、IP地址和端口等信息。&lt;/p>
&lt;p>可以让每个进程拥有自己独立的IP地址，端口和网卡信息&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>首先查看主机上的ip 信息&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>vagrant@docker ~&lt;span class="o">]&lt;/span>$ ip a
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu &lt;span class="m">65536&lt;/span> qdisc noqueue state UNKNOWN group default qlen &lt;span class="m">1000&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> inet 127.0.0.1/8 scope host lo
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> valid_lft forever preferred_lft forever
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> inet6 ::1/128 scope host
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> valid_lft forever preferred_lft forever
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span class="m">1500&lt;/span> qdisc mq state UP group default qlen &lt;span class="m">1000&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> link/ether 00:15:5d:25:01:09 brd ff:ff:ff:ff:ff:ff
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> inet 172.29.5.132/20 brd 172.29.15.255 scope global noprefixroute dynamic eth0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> valid_lft 82979sec preferred_lft 82979sec
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> inet6 fe80::215:5dff:fe25:109/64 scope link
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> valid_lft forever preferred_lft forever
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3: docker0: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu &lt;span class="m">1500&lt;/span> qdisc noqueue state DOWN group default
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> link/ether 02:42:f0:82:11:e0 brd ff:ff:ff:ff:ff:ff
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> valid_lft forever preferred_lft forever
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>创建 net namespace&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>vagrant@docker ~&lt;span class="o">]&lt;/span>$ sudo unshare --net --fork /bin/bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@docker vagrant&lt;span class="o">]&lt;/span>&lt;span class="c1">#&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用 ip a命令查看当前namespace的网络信息&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@docker vagrant&lt;span class="o">]&lt;/span>&lt;span class="c1"># ip a&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1: lo: &amp;lt;LOOPBACK&amp;gt; mtu &lt;span class="m">65536&lt;/span> qdisc noop state DOWN group default qlen &lt;span class="m">1000&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="为什么-docker-需要-namespace">为什么 docker 需要 namespace?&lt;/h3>
&lt;p>Linux 内核从2002年2.4.19版本开始加入了 Mount Namspace&lt;/p>
&lt;p>内核3.8版本加入了 User Namespace 为容器提供了足够的支持功能&lt;/p>
&lt;p>当 docker 新建一个容器时&lt;/p>
&lt;p>会创建这六种 namespace， 然后将容器中的进程加入这些 namespace之中&lt;/p>
&lt;h1 id="cgroups">Cgroups&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>定义&lt;/p>
&lt;p>全程是 control groups， 是Linux 内核的一个功能。可以实现限制进程或者进程组的资源（cpu、mem、磁盘IO等）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>特征&lt;/p>
&lt;p>资源限制：限制资源的使用量&lt;/p>
&lt;p>优先级控制： 不同的组可以有不用的资源使用优先级&lt;/p>
&lt;p>审计：计算控制组的资源使用情况&lt;/p>
&lt;p>控制： 控制进程的挂起或恢复&lt;/p>
&lt;/li>
&lt;li>
&lt;p>核心&lt;/p>
&lt;p>subsystem: 一个内核的组件，代表一类资源调度控制器&lt;/p>
&lt;p>cgroup： 表示一组进程和一组带有参数的子系统的关联关系&lt;/p>
&lt;p>hierarchy：由一些列的控制组按照树状结构排列组成的子控制组默认拥有父控制组的属性&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="subsystem">subsystem&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>查看当前主机使用了哪些子系统&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>vagrant@docker ~&lt;span class="o">]&lt;/span>$ sudo mount -t cgroup
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cgroup on /sys/fs/cgroup/systemd &lt;span class="nb">type&lt;/span> cgroup &lt;span class="o">(&lt;/span>rw,nosuid,nodev,noexec,relatime,seclabel,xattr,release_agent&lt;span class="o">=&lt;/span>/usr/lib/systemd/systemd-cgroups-agent,name&lt;span class="o">=&lt;/span>systemd&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cgroup on /sys/fs/cgroup/cpuset &lt;span class="nb">type&lt;/span> cgroup &lt;span class="o">(&lt;/span>rw,nosuid,nodev,noexec,relatime,seclabel,cpuset&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cgroup on /sys/fs/cgroup/cpu,cpuacct &lt;span class="nb">type&lt;/span> cgroup &lt;span class="o">(&lt;/span>rw,nosuid,nodev,noexec,relatime,seclabel,cpuacct,cpu&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cgroup on /sys/fs/cgroup/perf_event &lt;span class="nb">type&lt;/span> cgroup &lt;span class="o">(&lt;/span>rw,nosuid,nodev,noexec,relatime,seclabel,perf_event&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cgroup on /sys/fs/cgroup/blkio &lt;span class="nb">type&lt;/span> cgroup &lt;span class="o">(&lt;/span>rw,nosuid,nodev,noexec,relatime,seclabel,blkio&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cgroup on /sys/fs/cgroup/memory &lt;span class="nb">type&lt;/span> cgroup &lt;span class="o">(&lt;/span>rw,nosuid,nodev,noexec,relatime,seclabel,memory&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cgroup on /sys/fs/cgroup/hugetlb &lt;span class="nb">type&lt;/span> cgroup &lt;span class="o">(&lt;/span>rw,nosuid,nodev,noexec,relatime,seclabel,hugetlb&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cgroup on /sys/fs/cgroup/freezer &lt;span class="nb">type&lt;/span> cgroup &lt;span class="o">(&lt;/span>rw,nosuid,nodev,noexec,relatime,seclabel,freezer&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cgroup on /sys/fs/cgroup/net_cls,net_prio &lt;span class="nb">type&lt;/span> cgroup &lt;span class="o">(&lt;/span>rw,nosuid,nodev,noexec,relatime,seclabel,net_prio,net_cls&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cgroup on /sys/fs/cgroup/devices &lt;span class="nb">type&lt;/span> cgroup &lt;span class="o">(&lt;/span>rw,nosuid,nodev,noexec,relatime,seclabel,devices&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cgroup on /sys/fs/cgroup/pids &lt;span class="nb">type&lt;/span> cgroup &lt;span class="o">(&lt;/span>rw,nosuid,nodev,noexec,relatime,seclabel,pids&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>以 cpu 子系统为例，演示 cgroups 如何限制进程的 cpu使用时间&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#在cpu子系统下创建测试文件夹&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mkdir /sys/fs/cgroup/cpu/mydocker
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#查看&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@docker vagrant&lt;span class="o">]&lt;/span>&lt;span class="c1"># ls /sys/fs/cgroup/cpu/mydocker -l&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">total &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-r--r--. &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 15:15 cgroup.clone_children
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--w--w--w-. &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 15:15 cgroup.event_control
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-r--r--. &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 15:15 cgroup.procs
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-r--r--r--. &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 15:15 cpuacct.stat
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-r--r--. &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 15:15 cpuacct.usage
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-r--r--r--. &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 15:15 cpuacct.usage_percpu
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-r--r--. &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 15:15 cpu.cfs_period_us
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-r--r--. &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 15:15 cpu.cfs_quota_us
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-r--r--. &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 15:15 cpu.rt_period_us
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-r--r--. &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 15:15 cpu.rt_runtime_us
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-r--r--. &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 15:15 cpu.shares
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-r--r--r--. &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 15:15 cpu.stat
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-r--r--. &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 15:15 notify_on_release
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-rw-r--r--. &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> Feb &lt;span class="m">26&lt;/span> 15:15 tasks
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 将当前shell进程加入cgroup&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@docker mydocker&lt;span class="o">]&lt;/span>&lt;span class="c1"># echo $$&amp;gt; tasks&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看tasks文件内容&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@docker mydocker&lt;span class="o">]&lt;/span>&lt;span class="c1">#&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>mem&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;span class="lnt">60
&lt;/span>&lt;span class="lnt">61
&lt;/span>&lt;span class="lnt">62
&lt;/span>&lt;span class="lnt">63
&lt;/span>&lt;span class="lnt">64
&lt;/span>&lt;span class="lnt">65
&lt;/span>&lt;span class="lnt">66
&lt;/span>&lt;span class="lnt">67
&lt;/span>&lt;span class="lnt">68
&lt;/span>&lt;span class="lnt">69
&lt;/span>&lt;span class="lnt">70
&lt;/span>&lt;span class="lnt">71
&lt;/span>&lt;span class="lnt">72
&lt;/span>&lt;span class="lnt">73
&lt;/span>&lt;span class="lnt">74
&lt;/span>&lt;span class="lnt">75
&lt;/span>&lt;span class="lnt">76
&lt;/span>&lt;span class="lnt">77
&lt;/span>&lt;span class="lnt">78
&lt;/span>&lt;span class="lnt">79
&lt;/span>&lt;span class="lnt">80
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 在memory子系统下创建cgroup&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@docker mydocker&lt;span class="o">]&lt;/span>&lt;span class="c1"># mkdir /sys/fs/cgroup/memory/mydocker&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 查看新建目录中的内容&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@docker mydocker&lt;span class="o">]&lt;/span>&lt;span class="c1"># ls&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cgroup.clone_children
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cgroup.event_control
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cgroup.procs
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.failcnt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.force_empty
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.kmem.failcnt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.kmem.limit_in_bytes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.kmem.max_usage_in_bytes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.kmem.slabinfo
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.kmem.tcp.failcnt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.kmem.tcp.limit_in_bytes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.kmem.tcp.max_usage_in_bytes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.kmem.tcp.usage_in_bytes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.kmem.usage_in_bytes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.limit_in_bytes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.max_usage_in_bytes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.memsw.failcnt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.memsw.limit_in_bytes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.memsw.max_usage_in_bytes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.memsw.usage_in_bytes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.move_charge_at_immigrate
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.numa_stat
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.oom_control
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.pressure_level
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.soft_limit_in_bytes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.stat
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.swappiness
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.usage_in_bytes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memory.use_hierarchy
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">notify_on_release
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tasks
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 限制内存使用&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@docker mydocker&lt;span class="o">]&lt;/span>&lt;span class="c1"># echo 1073741824 &amp;gt; memory.limit_in_bytes&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 将当前shell写入tasks内&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@docker mydocker&lt;span class="o">]&lt;/span>&lt;span class="c1"># echo $$&amp;gt;tasks&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@docker mydocker&lt;span class="o">]&lt;/span>&lt;span class="c1"># cat tasks&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">3356&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">3484&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 申请内存，当达到1G时 被杀死&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@docker mydocker&lt;span class="o">]&lt;/span>&lt;span class="c1"># memtester 1500M 1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memtester version 4.3.0 &lt;span class="o">(&lt;/span>64-bit&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Copyright &lt;span class="o">(&lt;/span>C&lt;span class="o">)&lt;/span> 2001-2012 Charles Cazabon.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Licensed under the GNU General Public License version &lt;span class="m">2&lt;/span> &lt;span class="o">(&lt;/span>only&lt;span class="o">)&lt;/span>.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pagesize is &lt;span class="m">4096&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pagesizemask is 0xfffffffffffff000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">want 1500MB &lt;span class="o">(&lt;/span>&lt;span class="m">1572864000&lt;/span> bytes&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">got 1500MB &lt;span class="o">(&lt;/span>&lt;span class="m">1572864000&lt;/span> bytes&lt;span class="o">)&lt;/span>, trying mlock ...Killed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 修改申请大小，完美&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>root@docker mydocker&lt;span class="o">]&lt;/span>&lt;span class="c1"># memtester 500M 1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memtester version 4.3.0 &lt;span class="o">(&lt;/span>64-bit&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Copyright &lt;span class="o">(&lt;/span>C&lt;span class="o">)&lt;/span> 2001-2012 Charles Cazabon.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Licensed under the GNU General Public License version &lt;span class="m">2&lt;/span> &lt;span class="o">(&lt;/span>only&lt;span class="o">)&lt;/span>.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pagesize is &lt;span class="m">4096&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pagesizemask is 0xfffffffffffff000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">want 500MB &lt;span class="o">(&lt;/span>&lt;span class="m">524288000&lt;/span> bytes&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">got 500MB &lt;span class="o">(&lt;/span>&lt;span class="m">524288000&lt;/span> bytes&lt;span class="o">)&lt;/span>, trying mlock ...locked.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Loop 1/1:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Stuck Address : ok
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Random Value : ok
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Compare XOR : ok
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Compare SUB : ok
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Compare MUL : ok
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Compare DIV : ok
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Compare OR : ok
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Compare AND : ok
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Sequential Increment: ok
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Solid Bits : ok
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Block Sequential : ok
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Checkerboard : ok
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Bit Spread : ok
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>docker 是如何使用cgroups的？&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">docker run -ti -m&lt;span class="o">=&lt;/span>1g nginx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul></description></item><item><title>Go, how to play?</title><link>http://cugbtang.github.io/post/series-go-1/</link><pubDate>Thu, 01 Mar 2018 16:01:23 +0800</pubDate><guid>http://cugbtang.github.io/post/series-go-1/</guid><description>&lt;h1 id="go-的io">Go 的IO&lt;/h1>
&lt;h2 id="首要问题内核中的缓冲和进程中的缓冲">首要问题，内核中的缓冲和进程中的缓冲&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>内核中的缓冲&lt;/p>
&lt;p>无论进程是否提供缓冲，内核都是提供缓冲的，系统对磁盘的读写都会提供一个缓冲（page/buffer cache），将数据写入到页/块缓冲进行排队，当页/块缓冲达到一定的量时，才能把数据写入磁盘。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>进程中的缓冲&lt;/p>
&lt;p>是指对输入输出流进行了改进，提供了流缓冲。当调用一个函数向磁盘写数据时，先把数据写入缓冲区，当达到某个条件后，如流缓冲满了，或者刷新流缓冲，这时候才会把数据一次送往内核提供的页/块缓冲区中，再经页/块化重写入磁盘。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="operating-system-----linux的文件io系统">Operating System &amp;mdash; linux的文件I/O系统&lt;/h2>
&lt;ul>
&lt;li>引言&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>操作系统首先是一个系统，一般由不同的模块组成，往往主要功能是xxx的&lt;strong>增删改查&lt;/strong>功能。操作系统主要是管理硬件和提供给我们一个舒适的开发环境的作用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>操作系统可以分为多个&lt;strong>子系统&lt;/strong>（VFS算一个），各个子系统又有多个&lt;strong>模块&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为什么处理器设有两种模式？&lt;/p>
&lt;p>内核态和用户态，&lt;strong>安全第一&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>虚拟内存。其实本质上很简单，就是操作系统将程序常用的数据放到内存里加速访问，不常用的数据放在磁盘上。 这一切对用户程序来说完全是透明的，用户程序可以假装所有数据都在内存里，然后通过虚拟内存地址去访问数据。在这背后，操作系统会自动将数据在主存和磁盘之间进行交换。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.jianshu.com/p/1ffde2de153f">操作系统对内存的管理机&lt;/a>&lt;/p>
&lt;p>突然想到一个哲学问题，跟生活是相关的。像我们平时生活一样，总是尽可能的把每个东西用尽 用好 用到它的最大极限。同理， Go 语言的内存管理是参考 tcmalloc 实现的，它其实就是利用好了 OS 管理内存的这些特点，来最大化内存分配性能的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.jianshu.com/p/7405b4e11ee2">Go 语言是如何利用底层的这些特性来优化内存的？&lt;/a>&lt;/p>
&lt;ul>
&lt;li>内存分配大多时候都是&lt;strong>在用户态&lt;/strong>完成的，不需要频繁进入内核态。&lt;/li>
&lt;li>每个 P 都有独立的 span cache，多个 CPU 不会并发读写同一块内存，进而减少 CPU L1 cache 的 cacheline 出现 dirty 情况，增大 cpu cache 命中率。&lt;/li>
&lt;li>内存碎片的问题，Go 是自己在用户态管理的，在 OS 层面看是没有碎片的，使得操作系统层面对碎片的管理压力也会降低。&lt;/li>
&lt;li>mcache 的存在使得内存分配不需要加锁。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Linux中VFS &amp;mdash;&amp;gt; 文件IO系统&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://i.loli.net/2021/09/25/XcNevS9PrLdy6IW.png" alt="">&lt;/p>
&lt;p>​ 如上图所示，page cache的本质是由 Linux 内核管理的内存区域。我们通过 mmap 以及 buffered IO 将文件读取到内存空间。实际上，都是读取到 page cache中。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>page cache&lt;/p>
&lt;blockquote>
&lt;p>除了 Direct IO，与磁盘相关的文件读写都有使用到 page cache技术&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>kernel 2.6以后（引入了虚拟内存），page cache 面向文件&lt;/li>
&lt;li>文件I/O （系统I/O）操作只和page cache交互&lt;/li>
&lt;li>用在所有&lt;strong>以文件为单元&lt;/strong>的场景中，比如网络文件系统&lt;/li>
&lt;li>address_space 作为文件系统和页缓存的中间适配器，用来指示一个文件在page cache中已经缓存了的物理页&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>如何查看OS的 page cache?&lt;/p>
&lt;p>通过读取 /proc/meminfo 文件，能够实时获取系统内存情况：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">$ cat /proc/meminfo
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Buffers: &lt;span class="m">1224&lt;/span> kB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Cached: &lt;span class="m">111472&lt;/span> kB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SwapCached: &lt;span class="m">36364&lt;/span> kB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Active: &lt;span class="m">6224232&lt;/span> kB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Inactive: &lt;span class="m">979432&lt;/span> kB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Active&lt;span class="o">(&lt;/span>anon&lt;span class="o">)&lt;/span>: &lt;span class="m">6173036&lt;/span> kB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Inactive&lt;span class="o">(&lt;/span>anon&lt;span class="o">)&lt;/span>: &lt;span class="m">927932&lt;/span> kB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Active&lt;span class="o">(&lt;/span>file&lt;span class="o">)&lt;/span>: &lt;span class="m">51196&lt;/span> kB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Inactive&lt;span class="o">(&lt;/span>file&lt;span class="o">)&lt;/span>: &lt;span class="m">51500&lt;/span> kB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Shmem: &lt;span class="m">10000&lt;/span> kB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SReclaimable: &lt;span class="m">43532&lt;/span> kB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>根据上面的数据，你可以简单得出这样的公式：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">page cache = buffers + cached + swap = active + inactive + share + swap
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>为什么 swap 和 buffers 也是 page cache的一部分？&lt;/p>
&lt;p>因为当匿名页 Inactive(anon)以及 Active(anon) 先被交换到磁盘（out）后，然后再加载回（in）内存中，由于读入到内存后原来地 swap file 还在，所以 swap cached 也可以认为是 File-backed page，即属于 page cache。过程如下图所示：&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/09/25/DNl5Ov3rgIc6ZjQ.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>page 和 page cache&lt;/p>
&lt;p>page 是内核内存管理分配的基本单位（4KB）&lt;/p>
&lt;p>page cache 由多个page构成（4KB的整数倍）&lt;/p>
&lt;p>&lt;strong>注意&lt;/strong>：并不是所有 page 都被组织成为 page cache&lt;/p>
&lt;p>Linux 系统上供用户可访问的内存分为两个类型：&lt;/p>
&lt;ol>
&lt;li>File-backed pages: 文件备份页，也就是page cache中的 page，对应于磁盘上的若干数据块；对于这些页最大的问题是脏页回盘&lt;/li>
&lt;li>Anonymous pages: 匿名页不对应磁盘上的任何磁盘数据块，他们是进程的运行内存空间，比如方法栈、局部变量等属性&lt;/li>
&lt;/ol>
&lt;p>两种类型在 swap 机制下的性能比较：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>File-backed pages的内存回收代价较低。page cache 通常对应于一个文件上的若干顺序块， 因此可以通过顺序IO的方式落盘。另一方面，如果 page cache 上没有进行写操作（即没有脏页），甚至不会将page cache 回盘，因为数据的内容完全可以通过再次读取磁盘文件得到。&lt;/p>
&lt;p>page cache 的主要难点在于脏页回盘，怎么个难法呢？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Anonymous pages 的内存会后代价较高。因为这种pages 通常随机地写入持久化交换设备。另一方面，无论是否有写操作，为了确保数据不丢失，Anonymous pages在swap时必须持久化到磁盘。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>swap 与 缺页中断&lt;/p>
&lt;p>&lt;a href="https://lwn.net/Articles/690079/">swap 机制&lt;/a>指地是当物理内存不够用，内存管理单元（MMU）需要提供&lt;strong>调度算法&lt;/strong>来回收相关内存空间，然后将清理出来地内存空间给当前内存申请方。&lt;/p>
&lt;p>swap 存在地本质原因是 Linux 系统提供了虚拟内存管理机制。每个进程都认为自己独占内存空间，因此所有进程地内存空间之和远远大于物理内存。所有进程的内存空间之和超过物理内存的部分就需要交换到磁盘上。&lt;/p>
&lt;p>OS以 page 为单位管理内存，当进程发现需要访问的数据不在内存时，OS可能会将数据以页的方式加载到内存中，上述过程被称为缺页中断。当OS发生缺页中断时，就会通过系统调用将 page 再次读到内存中。&lt;/p>
&lt;p>但主内存的空间时有限的，当主内存中不包含可以使用的空间时，OS会选择合适的物理内存逐页驱逐回磁盘，为新的内存页让出位置，选择待驱逐页的过程在OS中叫做页面替换（page replacement）,替换操作又会触发 swap 机制。&lt;/p>
&lt;p>如果物理内存足够大，那么可能不需要 swap 机制，但是 swap 在这种情况下还是有一定优势：对于有发生内存泄漏几率的应用程序（进程）, swap交换分区更是重要，这可以确保内存泄漏不至于导致物理内存不够用，最终导致系统崩溃。但内存泄漏会引起频繁的 swap，此时会非常影响OS的性能。&lt;/p>
&lt;p>Linux 通过一个 swappiness 参数来控制 swap 机制：这个参数可为 0~100，控制系统swap的优先级。&lt;/p>
&lt;ol>
&lt;li>高数值，较高频率的swap，进程不活跃时将其转换出物理内存&lt;/li>
&lt;li>低数值，较低频率的swap，这可以确保交互式不因为内存空间频繁地交换到磁盘而提高响应延迟。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>page cache 和 buffer cache&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">~ free -m
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> total used free shared buffers cached
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Mem: &lt;span class="m">128956&lt;/span> &lt;span class="m">96440&lt;/span> &lt;span class="m">32515&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">5368&lt;/span> &lt;span class="m">39900&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-/+ buffers/cache: &lt;span class="m">51172&lt;/span> &lt;span class="m">77784&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Swap: &lt;span class="m">16002&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">16001&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其中，cached 表示当前的页缓存（page cache）占用量，用于缓存文件的页数据；页是逻辑上的概念，因此page cache 是与文件系统同级的&lt;/p>
&lt;p>buffers 表示当前的块缓存（buffer cache）占用量，用于缓存块设备的块数据；块是物理上的概念，因此buffer cache是与块设备驱动程序同级的。&lt;/p>
&lt;p>page cache 和 buffer cache的共同目的都是加速数据IO。写数据时，首先写到缓存，将写入的页标记为 dirty，然后向外部存储 flush，也就是缓存写机制中的 write-back（另一种是 write-through，Linux默认情况下不采用）；读数据时，首先读取缓存，如果命中，再去外部存储读取，并且将读取来的数据页加入缓存。OS&lt;strong>总是积极地&lt;/strong>将所有空闲内存都用做 page cache和 buffer cache，当内存不够用时，也会用LRU等算法淘汰缓存页。&lt;/p>
&lt;p>在Linux 2.4 内核之前，page cache 和 buffer cache是完全分离的。但是，块设备大多是磁盘，磁盘上的数据又大多通过文件系统来组织，这种设计导致很多数据被缓存了两次，浪费内存。所以，**在2.4版本之后，两块缓存近似融合在了一起，如果一个文件的页加载到了 page cache，那么同时 buffer cache只需要维护块指向页的指针就可以了。**只有那么没有用文件表示的块，或者绕过了OS直接操作的块（如dd命令），才会真正放到 buffer cache中。因此，我们现在提起 page cache，基本上都同时指 page cache 和 buffer cache 两者。&lt;/p>
&lt;p>下图近似地给出 32位 Linux系统中可能地一种 page cache结构：&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/09/25/EQ6xXHyPtrSldbf.png" alt="">&lt;/p>
&lt;p>block size = 1KB&lt;/p>
&lt;p>page size = 4KB&lt;/p>
&lt;p>page cache中的每个文件都是一棵&lt;strong>基数树&lt;/strong>（radix tree,本质上是多差搜索树），树的每个节点都是一个页。根据文件内的偏移量就可以快速定位到所在的页，如下图所示。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/09/25/U7RhXsNSZfCOj1Y.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>page cache与预读&lt;/p>
&lt;p>OS为基于page cache的读缓存机制提供预读机制（PAGE_READAHEAD）,eg:&lt;/p>
&lt;ol>
&lt;li>用户线程仅仅请求读取磁盘上文件A的offset为0-3KB范围内的数据，由于磁盘的基本读写单位为 block = 4KB，于是OS至少会读0-4KB的内容，这恰好可以在一个page中装下。&lt;/li>
&lt;li>但是OS处于&lt;a href="https://spongecaptain.cool/SimpleClearFileIO/1.%20page%20cache.html">局部性原理&lt;/a>会选择将磁盘块 offset[4KB,8KB)、[8KB,12KB)、[12KB,16KB)都加载到内存，于是额外在内存中申请了3个page。如下如图所示OS的预读机制：&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://i.loli.net/2021/09/25/WmBhwcnCUtoNdMQ.gif" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>page cache与文件持久化的一致性&lt;/p>
&lt;p>现代 Linux 的page cache正如其名，是对磁盘上的 page 的内存缓存，同时可以用于读/写操作。&lt;strong>任何系统引入缓存，就会引发一致性问题&lt;/strong>：内存中的数据与磁盘中的数据不一致，如最常见后端架构中的redis缓存与mysql数据库就存在一致性的问题。&lt;/p>
&lt;p>Linux 提供多种机制来保证数据一致性，但无论是单机上的内存与磁盘一致性，还是分布式组件中节点1与节点2、3的数据一致性问题，理解的关键是 trade-off：吞吐量与数据一致性保证是一对矛盾。&lt;/p>
&lt;p>首先，需要我们理解一下文件的数据，文件 = 元数据+数据。&lt;/p>
&lt;blockquote>
&lt;p>元数据=文件大小+创建时间+访问时间+属主属组等信息&lt;/p>
&lt;/blockquote>
&lt;p>Linux 采用以下两种方式实现文件一致性：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Write Through(写穿)：向用户层提供特定接口，应用程序可主动调用接口来保证文件一致性；&lt;/p>
&lt;p>以牺牲系统IO吞吐量为代价，向上层应用确保一旦写入，数据就已经落盘，不会丢失。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Write Back(写回)：系统中存在定期任务（表现形式为内核线程），周期性地同步文件系统中文件脏数据块，这就是默认的Linux一致性方案；&lt;/p>
&lt;p>在系统发生宕机的情况下无法确保数据已经落盘，因此存在数据丢失的问题。不过，在程序挂了，如被 kill -9, OS会确保page cache 中的数据落盘。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>两种方法都依赖系统调用，主要分为三种系统调用，可以分别由用户进程与内核进程发起：&lt;/p>
&lt;ol>
&lt;li>fsync(int fd)，将fd 代表的&lt;strong>文件的&lt;/strong>脏数据和脏元数据全部刷新到磁盘中&lt;/li>
&lt;li>fdatasync(int fd)，将 fd 代表的文件的脏数据刷新至磁盘，同时对必要的（文件大小，而文件修改时间等不属于必要信息）元数据刷新至磁盘中。&lt;/li>
&lt;li>sync()，对&lt;strong>系统中所有的&lt;/strong>脏的文件数据、元数据都刷新至磁盘中&lt;/li>
&lt;/ol>
&lt;p>描述一下内核线程的相关特性：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>创建的针对&lt;strong>回写任务&lt;/strong>的内核线程数由系统中持久存储设备决定，为每个存储设备创建单独的刷新线程；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>关于&lt;strong>多线程的架构&lt;/strong>问题，Linux内核采取了 Lighthttp 的做法。即系统中存在一个管理线程和多个刷新线程（每个持久存储设备对应一个刷新线程）。管理线程监控设备上的脏页面情况，若设备一段时间内没有产生脏页面，就销毁设备上的刷新线程；若监测到设备上有脏页面需要回写且尚未为该设备创建刷新线程，那么创建刷新线程处理脏页面回写。而刷新线程的任务较为单调，只负责将设备中的脏页面回写至持久存储设备中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>刷新线程刷新设备上脏页面大致设计如下：&lt;/p>
&lt;p>每个设备保存脏文件链表，保存的是该设备上存储的脏文件的inode节点。所谓的回写文件脏页面即回写该 inode 链表上的某些文件的脏页面；&lt;/p>
&lt;p>系统中存在多个回写时机。第一，应用程序主动调用回写接口；第二，管理线程周期性地唤醒设备上的回写线程进行回写；第三，某些应用程序/内核任务发现内存不足时要回收部分缓存页面而事先进行脏页面回写，设计一个统一的框架来管理这些回写任务非常有必要。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>优势，好处，特点，独特。。。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>加快数据访问&lt;/p>
&lt;/li>
&lt;li>
&lt;p>减少IO次数，提高系统磁盘IO吞吐量&lt;/p>
&lt;p>得益于 page cache的缓存以及预读能力，而程序又往往符合局部性原理。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>劣势，缺点，不足。。。&lt;/p>
&lt;ol>
&lt;li>最直接的缺点就是需要占用&lt;strong>额外&lt;/strong>物理内存空间，物理内存在比较紧张的时候可能导致频繁的 swap 操作，最终导致系统的磁盘IO负载上升。（还是那个观点，工业4.0时代，多用点而内存会带来人们的美好生活）&lt;/li>
&lt;li>对应用层&lt;strong>没有提供&lt;/strong>很好的管理API，几乎是透明管理。应用层即使想优化 page cache的使用策略也很难进行。因为一些应用选择在用户空间实现自己的 page 管理，而不使用 page cache，例如 mysql 的 innoDB存储引擎以 16KB的页进行管理。（事实是提供了，但某人觉得满足不了他的美好生活，看来人们的美好生活是日益增长的）&lt;/li>
&lt;li>某些场景下&lt;a href="https://spongecaptain.cool/SimpleClearFileIO/2.%20DMA%20%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF.html">比 Direct IO多一次磁盘IO&lt;/a>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>零拷贝&lt;/p>
&lt;p>历史变迁：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>​ 没有任何优化技术的数据四次拷贝与四次上下文切换&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/09/25/pG4a8lrRYcZ5SQs.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DMA参与下的数据四次拷贝&lt;/p>
&lt;p>DMA 也有其局限性，DMA 仅仅能用于设备之间交换数据时进行数据拷贝，但是系统内部的数据拷贝还需要 CPU 进行，例如 CPU 需要负责内核空间数据与用户空间数据之间的拷贝（内存内部的拷贝） 。&lt;/p>
&lt;p>read buffer == page cache&lt;/p>
&lt;p>socket buffer == socket 缓冲区&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://i.loli.net/2021/09/25/VvQ9Sn67kPTGIx3.jpg" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>不同的零拷贝技术适用于不同的应用场景&lt;/p>
&lt;ul>
&lt;li>
&lt;p>DMA 技术回顾：DMA 负责内存与其他组件之间的数据拷贝，CPU 仅需负责管理，而无需负责全程的数据拷贝；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用 page cache 的 zero copy：&lt;/p>
&lt;/li>
&lt;li>
&lt;ol>
&lt;li>sendfile：一次代替 read/write 系统调用，通过使用 DMA 技术以及传递文件描述符，实现了 zero copy&lt;/li>
&lt;li>mmap：仅代替 read 系统调用，将内核空间地址映射为用户空间地址，write 操作直接作用于内核空间。通过 DMA 技术以及地址映射技术，用户空间与内核空间无须数据拷贝，实现了 zero copy&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>不使用 page cache 的 Direct I/O：读写操作直接在磁盘上进行，不使用 page cache 机制，通常结合用户空间的用户缓存使用。通过 DMA 技术直接与磁盘/网卡进行数据交互，实现了 zero copy&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>零拷贝&lt;strong>思想&lt;/strong>（ 不是不进行拷贝，而是 CPU 不再全程负责数据拷贝时的搬运工作 ）的一个具体实现。&lt;/p>
&lt;p>一种内存映射文件的方法，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一映射关系。&lt;/p>
&lt;p>零拷贝的特点是 CPU 不全程负责内存中的数据写入其他组件，CPU 仅仅起到管理的作用 。&lt;/p>
&lt;p>具体实现：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>sendfile&lt;/strong>（ 用户从磁盘读取一些文件数据后&lt;strong>不需要经过任何计算与处理&lt;/strong>就通过网络传输出去 ）&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/09/25/HehQIWMnpdSzAZB.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>mmap&lt;/strong>，利用 &lt;code>mmap()&lt;/code> 替换 &lt;code>read()&lt;/code>，配合 &lt;code>write()&lt;/code> 调用的整个流程如下：&lt;/p>
&lt;ol>
&lt;li>用户进程调用 &lt;code>mmap()&lt;/code>，从用户态陷入内核态，将内核缓冲区映射到用户缓存区；&lt;/li>
&lt;li>DMA 控制器将数据从硬盘拷贝到内核缓冲区（可见其使用了 Page Cache 机制）；&lt;/li>
&lt;li>&lt;code>mmap()&lt;/code> 返回，上下文从内核态切换回用户态；&lt;/li>
&lt;li>用户进程调用 &lt;code>write()&lt;/code>，尝试把文件数据写到内核里的套接字缓冲区，再次陷入内核态；&lt;/li>
&lt;li>CPU 将内核缓冲区中的数据拷贝到的套接字缓冲区；&lt;/li>
&lt;li>DMA 控制器将数据从套接字缓冲区拷贝到网卡完成数据传输；&lt;/li>
&lt;li>&lt;code>write()&lt;/code> 返回，上下文从内核态切换回用户态。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>splice&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>直接 Direct I/O&lt;/strong>（自缓存应用程序，数据库管理系统就是这类的一个代表）&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/09/25/nailwsNUbyM5xf1.jpg" alt="">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>不同的零拷贝技术适用于不同的应用&lt;strong>场景&lt;/strong> 。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>把mmap单独拿出来说&lt;/p>
&lt;p>用户空间mmap&amp;mdash;&amp;gt;内核空间mmap&amp;mdash;&amp;gt;缺页异常&lt;/p>
&lt;p>对比，&lt;a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html">从内核文件系统看文件读写过程&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>案例&lt;/p>
&lt;ol>
&lt;li>
&lt;p>kafaka&lt;/p>
&lt;p>使用 mmap 来对接收到的数据进行持久化，使用 sendfile 从持久化介质中读取数据然后对外发送是一对常用的组合。但是注意，你无法利用 sendfile 来持久化数据，利用 mmap 来实现 CPU 全程不参与数据搬运的数据拷贝。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="">mysql 的零拷贝技术&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>总而言之，常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从&lt;strong>磁盘到用户主存&lt;/strong>的一次数据拷贝过程。&lt;/p>
&lt;p>说白了，mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了不同空间数据不通的繁琐过程 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mmap&lt;/p>
&lt;p>一种内存映射文件的方法。将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。实现这样的映射关系后，进程就可以采用指针的方式读写这一段内存，而OS会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read、write等系统调用函数。相反，内核空间对这段区域的修改也直接反映到用户空间，从而可以实现不同进程间的文件共享。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/09/25/uhnNDGws3xR24Tk.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>特点&lt;/p>
&lt;ol>
&lt;li>mmap 向应用程序提供的内存访问接口是内存地址连续的，但是对应的磁盘文件的 block 可以不是地址连续的&lt;/li>
&lt;li>mmap 提供的内存空间是虚拟空间，而不是物理空间，因此完全可以分配远远大于物理内存大小的虚拟空间，如16G内存主机可以分配1000G的mmap内存空间&lt;/li>
&lt;li>mmap 负责映射文件逻辑上一段连续的数据（物理上可以不连续存储）映射为连续内存，而这里的文件可以是磁盘文件、驱动假造出来的文件以及设备&lt;/li>
&lt;li>mmap 由OS负责管理，对同一个文件地址的映射将被所有线程共享，OS确保线程安全及线程可见性&lt;/li>
&lt;/ol>
&lt;p>mmap 的设计很有启发性。基于磁盘的读写单位是 block(4KB)，而基于内存的读写单元是&lt;strong>地址&lt;/strong>。换言之，CPU进行一次磁盘读写操作涉及的数据量至少是4KB。但是，进行一次内存操作涉及的数据量是基于地址的，也就是通常的 64bit 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>模型&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/09/25/m9QcSfVAJ1dEigv.jpg" alt="">&lt;/p>
&lt;ol>
&lt;li>利用 DMA 技术来取代 CPU 来在内存与其他组件之间的数据拷贝，例如从磁盘到内存，从内存到网卡；&lt;/li>
&lt;li>用户空间的 mmap file 使用虚拟内存，实际上并不占据物理内存，只有在内核空间的 kernel buffer cache 才占据实际的物理内存；&lt;/li>
&lt;li>&lt;code>mmap()&lt;/code> 函数需要配合 &lt;code>write()&lt;/code> 系统调动进行配合操作，这与 &lt;code>sendfile()&lt;/code> 函数有所不同，后者一次性代替了 &lt;code>read()&lt;/code> 以及 &lt;code>write()&lt;/code>；因此 mmap &lt;strong>也至少&lt;/strong>需要 4 次上下文切换；&lt;/li>
&lt;li>mmap 仅仅能够避免内核空间到用户空间的全程 CPU 负责的数据拷贝，但是&lt;strong>内核空间内部&lt;/strong>还是需要全程 CPU 负责的数据拷贝&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>流程&lt;/p>
&lt;ol>
&lt;li>用户进程调用 &lt;code>mmap()&lt;/code>，从用户态陷入内核态，将内核缓冲区映射到用户缓存区；&lt;/li>
&lt;li>DMA 控制器将数据从硬盘拷贝到内核缓冲区（&lt;strong>可见其使用了 Page Cache 机制&lt;/strong>）；&lt;/li>
&lt;li>&lt;code>mmap()&lt;/code> 返回，上下文从内核态切换回用户态；&lt;/li>
&lt;li>用户进程调用 &lt;code>write()&lt;/code>，尝试把文件数据写到内核里的套接字缓冲区，再次陷入内核态；&lt;/li>
&lt;li>CPU 将内核缓冲区中的数据拷贝到的套接字缓冲区；&lt;/li>
&lt;li>DMA 控制器将数据从套接字缓冲区拷贝到网卡完成数据传输；&lt;/li>
&lt;li>&lt;code>write()&lt;/code> 返回，上下文从内核态切换回用户态。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>优势&lt;/p>
&lt;ol>
&lt;li>
&lt;p>简化用户进程编程&lt;/p>
&lt;p>基于缺页异常的懒加载&lt;/p>
&lt;p>数据一致性由OS确保&lt;/p>
&lt;/li>
&lt;li>
&lt;p>读写效率提高：避免内核空间到用户空间的数据拷贝&lt;/p>
&lt;/li>
&lt;li>
&lt;p>避免只读操作时的swap操作&lt;/p>
&lt;/li>
&lt;li>
&lt;p>节约内存&lt;/p>
&lt;p>用户空间与内核空间实际上公用同一份数据&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>适用场景，非常受限&lt;/p>
&lt;ol>
&lt;li>多个线程以&lt;strong>只读的方式&lt;/strong>同时访问一个文件，这是因为 mmap 机制下多线程共享了同一物理内存空间，因此节约了内存；&lt;/li>
&lt;li>mmap 非常适合用于&lt;strong>进程间通信&lt;/strong>，这是因为对同一文件对应的 mmap 分配的物理内存天然多线程共享，并可以依赖于操作系统的同步原语；&lt;/li>
&lt;li>mmap 虽然比 sendfile 等机制多了一次 CPU 全程参与的内存拷贝，但是用户空间与内核空间并不需要数据拷贝，因此在正确使用情况下并不比 sendfile 效率差；&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>不适合的场景&lt;/p>
&lt;ol>
&lt;li>由于 mmap 使用时&lt;strong>必须实现指定好&lt;/strong>内存映射的大小，因此 mmap 并不适合变长文件；&lt;/li>
&lt;li>如果&lt;strong>更新频繁&lt;/strong>，mmap 避免两态拷贝的优势就被摊还，最终还是落在了大量的脏页回写及由此引发的随机 I/O 上，所以在随机写很多的情况下，mmap 方式在效率上不一定会比带缓冲区的一般写快；&lt;/li>
&lt;li>读/写&lt;strong>小文件&lt;/strong>（例如 16K 以下的文件），mmap 与通过 read 系统调用相比有着更高的开销与延迟；同时 mmap 的&lt;strong>刷盘由系统全权控制&lt;/strong>，但是在小数据量的情况下由应用本身手动控制更好；&lt;/li>
&lt;li>mmap 受限于操作系统内存大小：例如在 32-bits 的操作系统上，虚拟内存总大小也就 2GB，但由于 mmap 必须要在内存中找到一块连续的地址块，此时你就无法对 4GB 大小的文件完全进行 mmap，在这种情况下你必须分多块分别进行 mmap，但是此时地址内存地址已经不再连续，使用 mmap 的意义大打折扣，而且引入了额外的复杂性；&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>参考&lt;/p>
&lt;p>&lt;a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html">认真分析mmap: 是什么 为什么 怎么用&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.zhihu.com/question/48161206">Linux中 mmap() 函数的内存映射问题理解？&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://stackoverflow.com/questions/258091/when-should-i-use-mmap-for-file-access">When should I use mmap for file access&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/308054212">Linux IO原理和Zero-copy技术全面揭秘&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="go-的io-1">Go 的IO&lt;/h2>
&lt;p>它的 io 和 bufio 是进程中（也可以说是&lt;strong>用户态&lt;/strong>）的缓冲。&lt;/p>
&lt;h3 id="go-和-io的不解之缘">Go 和 IO的不解之缘&lt;/h3>
&lt;p>Go 是一种高性能的编译型语言，天然支持高并发，用户级别封装协程，号称支持百万的协程并发，这个量级不是线程可比的。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>那Go支持如此高并发的秘诀在于？&lt;/p>
&lt;p>&lt;strong>执行体调度得当&lt;/strong>。CPU不停的在不同执行体（goroutine）之间反复横跳。CPU一直在装填和运行不同执行体的指令，G1 不行就搞G2，一刻都不能停，这样才能使得大量的执行体齐头并进，系统才能完成如此高并发的吞吐。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>那Go适合CPU密集型的程序，还是IO密集型的程序呢？&lt;/p>
&lt;p>**IO密集型。**首先，反推逻辑，CPU密集型就意味着每个执行体都是急需CPU的，G1都吃不饱，切到G2去干嘛，所以CPU密集型的程序最好的情况就是不调度，绑核都来不及呢。想要提高这种程序的性能，就是加钱，买核。&lt;/p>
&lt;p>IO设备和CPU是不同的独立设备。这两者之间的处理可以是并行运行的。Go程序的协程调度可以很好的利用这个关系。让CPU执行程序指令，只负责发送IO，一旦IO被设备接收，CPU不等待完成，就可以处理其他的指令，IO的完成以异步事件的形式触发。这样，IO设备的处理过程和CPU的执行就并行起来了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>任何IO都适配Go么？&lt;/p>
&lt;p>Go 语言级别把&lt;strong>网络IO做了异步化&lt;/strong>，但是文件IO还是同步的调用&lt;/p>
&lt;ol>
&lt;li>网络fd可以用epoll池来管理事件，实现异步IO&lt;/li>
&lt;li>文件fd不能用epoll池来管理事件，只能同步IO&lt;/li>
&lt;/ol>
&lt;p>文件想要实现异步IO，当前Linux下有种方式：&lt;/p>
&lt;ul>
&lt;li>AIO: 但Go没有封装实现&lt;/li>
&lt;li>io_uring: 内核版本要求高&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="go的io长什么样子">Go的IO长什么样子&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>IO接口描述&lt;/p>
&lt;p>&lt;code>io/io.go&lt;/code>不涉及具体的IO实现，只有&lt;strong>语义接口&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">Reader&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">Read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">p&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">n&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">Writer&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">Write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">p&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">n&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>按照接口的定义维度，大致可以分为3大类：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>基础类型&lt;/p>
&lt;p>Reader、Writer、Closer。。。等，描述了最原始的Go的IO的样子。如果你写代码的时候，要实现这些接口，千万要把标准库里的注释读三遍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>组合类型&lt;/p>
&lt;p>往往把最基本的接口组合起来，使用Go的embeding语法糖，比如：ReaderCloser、WriteCloser等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>进阶类型&lt;/p>
&lt;p>基于基础接口，加上一些有趣的实现。比如：TeeReader、LimitReader、MultiReader&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>IO 通用函数&lt;/p>
&lt;p>io库还有一些基于以上接口的函数，&lt;/p>
&lt;ul>
&lt;li>Copy&lt;/li>
&lt;li>CopyN&lt;/li>
&lt;li>CopyBuffer&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>io/ioutil&lt;/p>
&lt;p>顾名思义，这是一个工具类型的库，util嘛 啥都要有，相当于平时的快捷键。&lt;/p>
&lt;p>这就是个工具库，应付一些简单的场景：&lt;/p>
&lt;p>ReadFile、WriteFile、ReadDir&amp;hellip;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="io-的姿势多种多样">IO 的姿势多种多样&lt;/h3>
&lt;p>哈哈，这位博主的理解很特别，Go 标准io库定义了基础的语义接口，那具体实现呢？&lt;/p>
&lt;ol>
&lt;li>字节数组可以是 Reader / Writer ？&lt;/li>
&lt;li>内存结构体可以是 Reader 吗？&lt;/li>
&lt;li>文件可以是 Reader / Writer 吗？&lt;/li>
&lt;li>字符串可以是 Reader ？&lt;/li>
&lt;li>IO 能聚合来提高效率吗？&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>都可以&lt;/strong>！Go帮我们做好了一切！&lt;/p>
&lt;p>io库的拓扑&lt;/p>
&lt;p>IO行为都是以io库为中心发散的。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/09/24/KY9iy2JV7xo5WpP.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>io 和 字节的故事： bytes 库&lt;/p>
&lt;p>一句话，内存块可以作为读写的数据流。&lt;/p>
&lt;p>bytes.Reader 可以把[]byte转换成Reader&lt;/p>
&lt;p>bytes.Buffer可以把[]byte转换成Reader、Writer&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">buffer&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1024&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">readerFromBytes&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">bytes&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewReader&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">buffer&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">io&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Copy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ioutil&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Discard&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">readerFromBytes&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// n == 1024, err == nil
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;n=%v,err=%v\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nx">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>io和字符串的故事：strings库&lt;/p>
&lt;p>strings.Reader能够把字符串转换成Reader, 这个也特别有意思，直接能把字符串作为读源。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">data&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="s">&amp;#34;hello world&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">readerFromBytes&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">strings&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewReader&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">data&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">io&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Copy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ioutil&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Discard&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">readerFromBytes&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;n=%v,err=%v\n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nx">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>io和网络的故事：net库&lt;/p>
&lt;p>网络可以作为读写源，抽象成Reader、Writer的形式。&lt;/p>
&lt;p>服务端：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">handleConn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">conn&lt;/span> &lt;span class="nx">net&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Conn&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">defer&lt;/span> &lt;span class="nx">conn&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Close&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">buf&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4096&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">conn&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">buf&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">conn&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Write&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="nb">byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;pong: &amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">conn&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">buf&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">server&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">net&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Listen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;tcp&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;:9999&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatalf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;err:%v&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">server&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Accept&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Fatalf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;err:%v&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="nf">handleConn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">c&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>说明：&lt;/p>
&lt;ol>
&lt;li>net.Listen 创建一个监听套接字，在Go里面封装成了 net.Listener&lt;strong>类型&lt;/strong>&lt;/li>
&lt;li>Accept 函数返回一个 net.Conn，代表一条网络连接，net.Conn 即是Reader，又是Writer，到了之后各自处理即可&lt;/li>
&lt;/ol>
&lt;p>客户端：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">conn&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">net&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Dial&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;tcp&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;:9999&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">panic&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">err&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">conn&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Write&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="nb">byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;hello world\n&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">io&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Copy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Stdout&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">conn&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>说明：&lt;/p>
&lt;ol>
&lt;li>net.Dail 传入服务器端地址和网络协议类型，即可返回一条和服务端通信的网络连接，返回的结构为 net.Conn&lt;/li>
&lt;li>net.Conn既可作为读端，也可为写端&lt;/li>
&lt;/ol>
&lt;p>以上无论是net.Listener，还是net.Conn 都是基于系统调用 socket 之上的一层封装。底层使用的是类似的系统调用：&lt;/p>
&lt;ul>
&lt;li>syscall.Socket&lt;/li>
&lt;li>syscall.Connect&lt;/li>
&lt;li>syscall.Listen&lt;/li>
&lt;li>syscall.GetsocketInt&lt;/li>
&lt;/ul>
&lt;p>Go 针对网络fd都会做哪些封装呢？&lt;/p>
&lt;ol>
&lt;li>创建还是用 socket 调用创建的 fd，创建出来就会立马设置为 nonblock 模式，Go的网络fd天然要使用IO多路复用的方式来走IO&lt;/li>
&lt;li>把 socket fd 丢到 epoll 池里（通过poll.runtime_pollOpen 把 socket 套接字加到epoll池里，底层调用的还是epollctl），监听事件&lt;/li>
&lt;li>封装好读写事件到来的函数回调&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>io和文件的故事： os库&lt;/p>
&lt;p>文件IO，这个是我们最常见的IO，文件可以作为读端，也可以作为写端。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> // 如下，把 test.data 的数据读出来丢到垃圾桶
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> fd, err := os.OpenFile(&amp;#34;test.data&amp;#34;, os.O_RDWR, 0)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if err != nil {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> panic(err)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> io.Copy(ioutil.Discard, fd)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里返回了一个File类型，不难想象这个是基于文件fd的一层封装。这里面做了什么呢？&lt;/p>
&lt;ul>
&lt;li>
&lt;p>调用系统调用 syscall.Open 拿到文件的fd，顺便设置了垃圾回收时候的析构函数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>stdin、stdout、stderr&lt;/p>
&lt;p>Go把这三个也都抽象成了读写源，这三个类型的变量其实就是File类型的变量，定义在源码 src/os/file.go中&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">var&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">Stdin&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">NewFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">uintptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">syscall&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Stdin&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s">&amp;#34;/dev/stdin&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">Stdout&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">NewFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">uintptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">syscall&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Stdout&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s">&amp;#34;/dev/stdout&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">Stderr&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">NewFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">uintptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">syscall&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Stderr&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s">&amp;#34;/dev/stderr&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>标准输入就可以和方便的作为读端（ &lt;code>Reader&lt;/code> ），标准输出可以作为写端（ &lt;code>Writer&lt;/code> ）&lt;/p>
&lt;p>eg：&lt;strong>用一行代码实现一个最简单的 echo 回显的程序&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 一行代码实现回显
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">io&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Copy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Stdout&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Stdin&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>缓存io的故事： bufio库&lt;/p>
&lt;p>&lt;strong>Reader/Writer 可以是缓冲 IO 的数据流&lt;/strong>&lt;/p>
&lt;p>Go缓冲IO是在&lt;strong>底层IO&lt;/strong>之上的一层buffer&lt;/p>
&lt;p>形象描述的话，可以说是&lt;strong>用户内存空间的page cache&lt;/strong>&lt;/p>
&lt;p>在 c 语言，有人肯定用过 &lt;code>fopen&lt;/code> 打开的文件（所谓的标准IO）：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="n">FILE&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nf">fopen&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">filename&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">mode&lt;/span> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>C 语言的缓冲IO有三种模式：&lt;/p>
&lt;ul>
&lt;li>全缓冲： 只有填满 buffer，才会真正的调用底层IO&lt;/li>
&lt;li>行缓冲：不用等填满buffer，遇到换行符，就会把IO下发下去&lt;/li>
&lt;li>不缓冲： bypass的模式，每次都是直接掉底层IO&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>四种方式，将数据写入文件&lt;/p>
&lt;ul>
&lt;li>
&lt;p>os包 f.Write([]byte)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">var&lt;/span> &lt;span class="nx">f&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">File&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">var&lt;/span> &lt;span class="nx">wireteString&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;你好,tcy&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">var&lt;/span> &lt;span class="nx">d1&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nb">byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">wireteString&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">f&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err3&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">os&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Create&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;./output.txt&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//创建文件
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">n2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err3&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">f&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">d1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//写入文件(字节数组) os方式
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>io包的io.WriteString(f, wireteString)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">var&lt;/span> &lt;span class="nx">wireteString&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;你好,tcy&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err1&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">io&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WriteString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">f&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">wireteString&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//写入文件(字符串),io方式,n为几个字节
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nx">f&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sync&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//Sync递交文件的当前内容进行稳定的存储。一般来说，这表示将文件系统的最近写入的数据在内存中的拷贝刷新到硬盘中稳定保存
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>ioutil包的ioutil.WriteFile&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">var&lt;/span> &lt;span class="nx">st&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nb">byte&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">wireteString&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">err2&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">ioutil&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">WriteFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;./output.txt&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">st&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mo">0666&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//写入文件(字节数组),如果文件不存在将按给出的权限创建文件，否则在写入数据之前清空文件。
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>bufio包中的bufio.NewWriter(f)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">var f *os.File
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">w := bufio.NewWriter(f) //创建新的 Writer 对象,NewReader创建一个具有默认大小缓冲、从r读取的*Reader
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">n4, err3 := w.WriteString(&amp;#34;你好,tcy&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fmt.Printf(&amp;#34;写入 %d 个字节n&amp;#34;, n4)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">w.Flush() //Flush方法将缓冲中的数据写入下层的io.Writer接口。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">f.Close()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/35277219">https://zhuanlan.zhihu.com/p/35277219&lt;/a>&lt;/p></description></item><item><title>Jenkins, how to play?</title><link>http://cugbtang.github.io/post/series-jenkins-1/</link><pubDate>Thu, 01 Mar 2018 16:01:23 +0800</pubDate><guid>http://cugbtang.github.io/post/series-jenkins-1/</guid><description>&lt;h1 id="how-to-play-jenkins">how to play jenkins?&lt;/h1>
&lt;blockquote>
&lt;p>社区源码、文档&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>等托管在 GitHub 上。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>其中基础设施部分在 &lt;a href="https://github.com/jenkins-infra">&lt;code>jenkins-infra&lt;/code>&lt;/a>；&lt;/p>
&lt;p>核心库以及插件在 &lt;a href="https://github.com/jenkinsci/">&lt;code>jenkinsci&lt;/code>&lt;/a>&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>；&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Jenkins 中文本地化相关的项目在 &lt;a href="https://github.com/jenkins-zh">&lt;code>jenkins-zh&lt;/code>&lt;/a>&lt;/p>
&lt;p>集中玩耍地地方&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/p>
&lt;/blockquote>
&lt;h2 id="搜集玩法">搜集玩法&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>1、官方建议容器化部署（docker/kubernetes）&lt;/p>
&lt;blockquote>
&lt;p>建议使用的Docker映像是&lt;a href="https://hub.docker.com/r/jenkinsci/blueocean/">&lt;code>jenkinsci/blueocean&lt;/code> image&lt;/a>(来自 the &lt;a href="https://hub.docker.com/">Docker Hub repository&lt;/a>)。 该镜像包含当前的&lt;a href="https://www.jenkins.io/download">长期支持 (LTS) 的Jenkins版本&lt;/a> （可以投入使用） ，捆绑了所有Blue Ocean插件和功能。这意味着你不需要单独安装Blue Ocean插件。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">docker run &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -u root &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --rm &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -d &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -p 8080:8080 &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -p 50000:50000 &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -v jenkins-data:/var/jenkins_home &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -v /var/run/docker.sock:/var/run/docker.sock &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> jenkinsci/blueocean
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>能玩一段时间了。。。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2、前面都是铺垫，玩了一段时间，发现原生镜像中缺这少那的，尤其是插件，看看&lt;strong>官方&lt;/strong>怎么说：&lt;/p>
&lt;blockquote>
&lt;p>Keep in mind that the process described above will automatically download the official Jenkins Docker image if this hasn’t been done before.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>Create Dockerfile with the following content:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">FROM jenkinsci/blueocean
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">USER root
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN apt-get update &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> apt-get install -y lsb-release
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN curl -fsSLo /usr/share/keyrings/docker-archive-keyring.asc &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> https://download.docker.com/linux/debian/gpg
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN &lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;deb [arch=&lt;/span>&lt;span class="k">$(&lt;/span>dpkg --print-architecture&lt;span class="k">)&lt;/span>&lt;span class="s2"> \
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> signed-by=/usr/share/keyrings/docker-archive-keyring.asc] \
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> https://download.docker.com/linux/debian \
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &lt;/span>&lt;span class="k">$(&lt;/span>lsb_release -cs&lt;span class="k">)&lt;/span>&lt;span class="s2"> stable&amp;#34;&lt;/span> &amp;gt; /etc/apt/sources.list.d/docker.list
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN apt-get update &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> apt-get install -y docker-ce-cli
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">USER jenkins
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN jenkins-plugin-cli --plugins &lt;span class="s2">&amp;#34;blueocean:1.25.3 docker-workflow:1.28&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>Build a new docker image from this Dockerfile and assign the image a meaningful name, e.g. &amp;ldquo;myjenkins-blueocean:2.319.3-1&amp;rdquo;:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">docker build -t myjenkins-blueocean:2.319.3-1 .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>3、同时，也可以站在巨人的肩膀上，有一些实践者把&lt;strong>常用的插件&lt;/strong>已经内置到镜像发布了，比如 &lt;code>kubespheredev/ks-jenkins&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>4、程序员用界面？命令行起飞&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://www.jenkins.io/zh/blog/2019/08/30/jenkins-cli/">利用 jcli 管理 Jenkins&lt;/a>&lt;/p>
&lt;p>vs&lt;/p>
&lt;p>&lt;a href="https://www.jenkins.io/doc/book/managing/cli/">原生Jenkins CLI &lt;/a>&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 例如，本地敏捷调试&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 安装&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wget -q https://ghproxy.com/https://github.com/jenkins-zh/jenkins-cli/releases/latest/download/jcli-linux-amd64.tar.gz&lt;span class="p">|&lt;/span>tar -zxvf &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> sudo mv jcli /usr/local/bin/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 配置&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">jcli config gen
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 都走默认就🆗&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 启动&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">jcli center start -m docker --image kubespheredev/ks-jenkins --version 2.249.1 --c-user root --port &lt;span class="m">8080&lt;/span> --setup-wizard&lt;span class="o">=&lt;/span>&lt;span class="nb">false&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>5、国内插件源&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>https://updates.jenkins-zh.cn/update-center.json&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>6、划重点，就是 &lt;strong>pipeline&lt;/strong>（前面的插件已经铺垫过）。what？？？&lt;/p>
&lt;blockquote>
&lt;h4 id="pipeline--持续交付即代码">pipeline ==~ “持续交付即代码”&lt;/h4>
&lt;p>Jenkins Pipeline 的定义通常被写入到一个文本文件（称为 &lt;code>Jenkinsfile&lt;/code> ）中，该文件可以被放入项目的源代码控制库中。&lt;/p>
&lt;p>official recommended how to play: &lt;strong>all in Jenkinsfile!!!&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://www.jenkins.io/doc/book/pipeline/getting-started">get started with Pipeline&lt;/a> - covers how to &lt;a href="https://www.jenkins.io/doc/book/pipeline/getting-started#defining-a-pipeline">define a Jenkins Pipeline&lt;/a> (i.e. your &lt;code>Pipeline&lt;/code>) through &lt;a href="https://www.jenkins.io/doc/book/pipeline/getting-started#through-blue-ocean">Blue Ocean&lt;/a>, through the &lt;a href="https://www.jenkins.io/doc/book/pipeline/getting-started#through-the-classic-ui">classic UI&lt;/a> or in &lt;a href="https://www.jenkins.io/doc/book/pipeline/getting-started#defining-a-pipeline-in-scm">SCM&lt;/a>,&lt;/li>
&lt;li>&lt;a href="https://www.jenkins.io/doc/book/pipeline/jenkinsfile">create and use a &lt;code>Jenkinsfile&lt;/code>&lt;/a> - covers use-case scenarios on how to craft and construct your &lt;code>Jenkinsfile&lt;/code>,&lt;/li>
&lt;li>work with &lt;a href="https://www.jenkins.io/doc/book/pipeline/multibranch">branches and pull requests&lt;/a>,&lt;/li>
&lt;li>&lt;a href="https://www.jenkins.io/doc/book/pipeline/docker">use Docker with Pipeline&lt;/a> - covers how Jenkins can invoke Docker containers on agents/nodes (from a &lt;code>Jenkinsfile&lt;/code>) to build your Pipeline projects,&lt;/li>
&lt;li>&lt;a href="https://www.jenkins.io/doc/book/pipeline/shared-libraries">extend Pipeline with shared libraries&lt;/a>,&lt;/li>
&lt;li>use different &lt;a href="https://www.jenkins.io/doc/book/pipeline/development">development tools&lt;/a> to facilitate the creation of your Pipeline, and&lt;/li>
&lt;li>work with &lt;a href="https://www.jenkins.io/doc/book/pipeline/syntax">Pipeline syntax&lt;/a> - this page is a comprehensive reference of all Declarative Pipeline syntax.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>（片段生成器+声明式+。。。反正就是生成）https://jenkins地址/job/test/pipeline-syntax/&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;a href="https://www.jenkins.io/doc/book/pipeline/">【官方词典】&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://raw.githubusercontent.com/cugbtang/image-repo/master/PicGo/20220302150355.png" alt="image-20220302150354810">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>7、&lt;strong>官方&lt;/strong>把架子打好了，让我们发挥是吧，那有木有前辈累计的模板，或者我有新颖的使用方式方法想分享给大家呢：&lt;/p>
&lt;blockquote>
&lt;p>enjoy your play:&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://github.com/jenkinsci/pipeline-examples">【官方例子】&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/devops-ws">【DevOps Workspace】&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>8、又玩了一段时间，发现jenkins最好是作为自动化的引擎，通过接口集成到 PASS 上。&lt;/p>
&lt;blockquote>
&lt;p>Use Pipeline through API&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://github.com/go-atomci/workflow">one example&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="都在玩儿plugin">都在玩儿plugin&lt;/h2>
&lt;ul>
&lt;li>Jenkins Configuration as Code&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>虽然新部署的 Jenkins 实例自动为我们安装了所有所需的插件，并配置好了初始化 Job 等工作，但在开始使用它之前，我们仍需要完成一系列手动工作，如配置 Jenkins 的 “Configure System” 页面&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>如果你是一名 Jenkins 管理员，那么你一定不会对这个页面感到陌生，每次部署完一个新的 Jenkins 实例，在可以使用之前，我们往往都需要在该页面作出一些相应的配置。该页面除了包含 Jenkins 自身的一些基本配置信息外，同时还包括了当前系统中所安装的插件的配置信息。也就是说，当你的 Jenkins 安装的插件越多，该页面的配置项就有可能会越多。&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="l">云时代 这个插件用处就少些了，所有的配置都放在&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>&lt;a href="https://github.com/jenkins-zh/jenkins-zh/wiki">https://github.com/jenkins-zh/jenkins-zh/wiki&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>&lt;a href="https://github.com/jenkinsci/">https://github.com/jenkinsci/&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>&lt;a href="https://github.com/jenkins-zh/jenkins-zh/issues">https://github.com/jenkins-zh/jenkins-zh/issues&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4" role="doc-endnote">
&lt;p>&lt;a href="https://github.com/jenkinsci/configuration-as-code-plugin/tree/master/demos">https://github.com/jenkinsci/configuration-as-code-plugin/tree/master/demos&lt;/a>&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Jenkins, Q&amp;A</title><link>http://cugbtang.github.io/post/series-jenkins-2/</link><pubDate>Thu, 01 Mar 2018 16:01:23 +0800</pubDate><guid>http://cugbtang.github.io/post/series-jenkins-2/</guid><description>&lt;h2 id="1镜像选择--jenkinsciblueocean----why">1、镜像选择 &lt;code>jenkinsci/blueocean&lt;/code> , why?&lt;/h2>
&lt;ul>
&lt;li>安装blue ocean插件前&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://i.loli.net/2021/10/27/r1wjF2aUuZ7vm9M.png" alt="">&lt;/p>
&lt;ul>
&lt;li>安装blue ocean插件后&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://i.loli.net/2021/10/27/3aJV4YNPRjdCtI1.png" alt="">&lt;/p>
&lt;h2 id="2启动参数都表示什么">2、启动参数都表示什么？&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">docker run &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --rm &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -u root &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -p 8080:8080 &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -v jenkins-data:/var/jenkins_home &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -v /var/run/docker.sock:/var/run/docker.sock &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -v &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$HOME&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>:/home &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> jenkinsci/blueocean
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;code>-p 8080:8080 &lt;/code> 映射（例如“发布”）jenkinsci/blueocean 容器的端口8080到主机上的端口8080。 第一个数字代表主机上的端口，而最后一个代表容器的端口。因此，如果您为此选项指定 -p 49000:8080 ，您将通过端口49000访问主机上的Jenkins。&lt;/li>
&lt;li>&lt;code>-p 50000:50000&lt;/code>（可选）将 jenkinsci/blueocean 容器的端口50000 映射到主机上的端口50000。 如果您在其他机器上设置了一个或多个基于JNLP的Jenkins代理程序，而这些代理程序又与 jenkinsci/blueocean 容器交互（充当“主”Jenkins服务器，或者简称为“Jenkins主”）， 则这是必需的。默认情况下，基于JNLP的Jenkins代理通过TCP端口50000与Jenkins主站进行通信。 您可以通过“ 配置全局安全性” 页面更改Jenkins主服务器上的端口号。如果您要将您的Jenkins主机的JNLP代理端口的TCP端口 值更改为51000（例如），那么您需要重新运行Jenkins（通过此 docker run … 命令）并指定此“发布”选项 -p 52000:51000，其中后一个值与Jenkins master上的这个更改值相匹配，第一个值是Jenkins主机的主机上的端口号， 通过它，基于JNLP的Jenkins代理与Jenkins主机进行通信 - 例如52000。&lt;/li>
&lt;li>&lt;code>-v jenkins-data:/var/jenkins_home&lt;/code>（可选，但强烈建议）映射在容器中的/var/jenkins_home 目录到具有名字 jenkins-data 的volume。 如果这个卷不存在，那么这个 docker run 命令会自动为你创建卷。 如果您希望每次重新启动Jenkins（通过此 docker run … 命令）时保持Jenkins状态，则此选项是必需的 。 如果你没有指定这个选项，那么在每次重新启动后，Jenkins将有效地重置为新的实例。
注意: 所述的 jenkins-data 卷也可以 docker volume create命令创建： docker volume create jenkins-data 代替映射 /var/jenkins_home 目录转换为Docker卷，还 可以将此目录映射到计算机本地文件系统上的目录。 例如，指定该选项 -v $HOME/jenkins:/var/jenkins_home 会将容器的 /var/jenkins_home 目录映射到 本地计算机上目录中的 jenkins 子目录， 该$HOME目录通常是 /Users/&lt;!-- raw HTML omitted -->/jenkins 或/home/&lt;!-- raw HTML omitted -->/jenkins 。&lt;/li>
&lt;li>&lt;code>-v /var/run/docker.sock:/var/run/docker.sock&lt;/code>（可选 /var/run/docker.sock 表示Docker守护程序通过其监听的基于Unix的套接字。 该映射允许 jenkinsci/blueocean 容器与Docker守护进程通信，如果jenkinsci/blueocean容器需要实例化其他Docker容器，则该守护进程是必需的。 如果运行声明式管道，其语法包含agent部分用 docker 例如， agent { docker { &amp;hellip; } } 此选项是必需的。&lt;/li>
&lt;/ul></description></item></channel></rss>