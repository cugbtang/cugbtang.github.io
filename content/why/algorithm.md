---
title: "algorithm why, how to play?"
date: 2023-11-30T16:01:23+08:00
lastmod: 2023-11-30T16:01:23+08:00
draft: true
tags: ["algorithm", "why"]
categories: ["algorithm"]
author: "cugbtang"
---

## data-structure

- 为什么数组访问是 O(1) 时间复杂度
- 为什么链表插入删除是 O(1) 时间复杂度
- 为什么栈需要 LIFO 原则
- 为什么队列需要 FIFO 原则
- 为什么哈希表需要哈希函数
- 为什么哈希表会有冲突
- 为什么二叉搜索树重要
- 为什么平衡树需要旋转操作
- 为什么堆有最大堆和最小堆之分
- 为什么图有邻接矩阵和邻接表两种表示
- 为什么树结构广泛使用
- 为什么跳表比有序链表高效
- 为什么布隆过滤器有误判率

## algorithm

- 为什么时间复杂度很重要
- 为什么空间复杂度很重要
- 为什么排序算法有不同选择
- 为什么快速排序平均时间复杂度是 O(n log n)
- 为什么归并排序稳定
- 为什么堆排序不需要额外空间
- 为什么冒泡排序效率低
- 为什么二分查找需要有序数组
- 为什么动态规划能解决重叠子问题
- 为什么贪心算法不一定得到最优解
- 为什么分治算法有效
- 为什么回溯算法能解决组合问题
- 为什么图算法重要

## sort

- 为什么快速排序在平均情况下最快
- 为什么归并排序稳定且高效
- 为什么堆排序适合大数据量
- 为什么冒泡排序在数据基本有序时很快
- 为什么插入排序适合小数据量
- 为什么选择排序不稳定
- 为什么计数排序适合整数排序
- 为什么桶排序适合均匀分布数据
- 为什么基数排序适合固定长度数据
- 为什么排序算法有稳定性要求
- 为什么原地排序节省空间
- 为什么外部排序处理大数据

## search

- 为什么二分查找比线性查找快
- 为什么哈希查找是 O(1) 时间复杂度
- 为什么树的查找是 O(log n) 时间复杂度
- 为什么图的查找复杂度高
- 为什么深度优先搜索使用栈
- 为什么广度优先搜索使用队列
- 为什么 A* 算法比 Dijkstra 高效
- 为什么二叉搜索树查找高效
- 为什么 B 树适合磁盘存储
- 为什么跳表查找高效
- 为什么索引能加速查找
- 为什么全文检索复杂度高

## graph

- 为什么图有有向图和无向图之分
- 为什么图有加权图和无权图之分
- 为什么最短路径算法重要
- 为什么最小生成树算法重要
- 为什么拓扑排序有依赖关系
- 为什么强连通分量重要
- 为什么二分图匹配有用
- 为什么网络流算法重要
- 为什么图着色问题是 NP 难问题
- 为什么图算法应用广泛
- 为什么邻接表适合稀疏图
- 为什么邻接矩阵适合稠密图

## dynamic-programming

- 为什么动态规划能避免重复计算
- 为什么动态规划需要最优子结构
- 为什么动态规划需要边界条件
- 为什么斐波那契数列适合动态规划
- 为什么背包问题是经典动态规划问题
- 为什么最长公共子序列需要动态规划
- 为什么编辑距离使用动态规划
- 为什么动态规划空间可以优化
- 为什么动态规划有自顶向下和自底向上之分
- 为什么记忆化搜索是动态规划的变种
- 为什么动态规划能解决组合优化问题
- 为什么动态规划在机器学习中重要